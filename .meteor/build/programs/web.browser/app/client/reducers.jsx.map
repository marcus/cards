{"version":3,"sources":["meteor://ğŸ’»app/client/reducers.jsx"],"names":[],"mappings":";;;;;;;;;;;;;;;eAOmC,OAAO;IAApC,YAAY,YAAZ,YAAY;IAAE,UAAU,YAAV,UAAU;;AAC9B,QAAQ,GAAG,EAAE,CAAC;;AAEd,IAAI,qBAAqB,GAAG;AAC1B,YAAU,EAAE,EAAE;CACf;;;AAGD,SAAS,KAAK,CAAC,QAAQ,EAAE,QAAQ,EAAE;AACjC,SAAO,CAAC,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;CACzC;;;;;AAKD,QAAQ,CAAC,aAAa;AAAG,WAAS,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE;AAC7D,SAAK,GAAG,KAAK,IAAI,qBAAqB,CAAC;;AAEvC,YAAQ,MAAM,CAAC,IAAI;AACjB,WAAK,aAAa;;;AAGhB,eAAO,KAAK,CAAC,KAAK,EAAE;AAClB,oBAAU,EAAE,MAAM,CAAC,MAAM;SAC1B,CAAC,CAAC;AACL;AACE,eAAO,KAAK,CAAC;AAAA,KAChB;GACF;;SAbiC,aAAa;IAa9C;;AAED,QAAQ,CAAC,KAAK;AAAG,WAAS,OAAO,CAAC,KAAK,EAAO,MAAM,EAAE;QAApB,KAAK,gBAAL,KAAK,GAAG,EAAE;;AAC1C,YAAQ,MAAM,CAAC,IAAI;AACjB,WAAK,eAAe;;;;AAIlB,YAAI,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AACtC,eAAO,IAAI,CAAC,IAAI,CAAC,UAAC,CAAC,EAAC,CAAC;iBAAK,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK;SAAA,CAAC,CAAC;AAC/C;AACE,eAAO,KAAK,CAAC;AAAA,KAChB;GACF;;SAXyB,OAAO;IAWhC,qE","file":"/client/reducers.jsx","sourcesContent":["// reducers allow you to 'slice' off a part of the single state object which\n// lets you think about the domain in a smaller picture. You could use one\n// reducer in a small app like this but in large apps this reducer could be\n// several hundred lines. See store.jsx to see how these reducers get 'combined'\n// into one single app state. We'll use two reducers, one for transient state\n// that the UI uses (selected id,name) and one for data (coming from Mongo)\n\nlet { cardsChanged, selectCard } = Actions;\nReducers = {};\n\nlet initialInterfaceState = {\n  selectedId: '',\n}\n\n// helper to *copy* old state and merge new data with it\nfunction merge(oldState, newState) {\n  return _.extend({}, oldState, newState);\n}\n\n// these reducers *must* be pure to use time-travel dev-tools\n// never directly mutate the `state` param, use merge instead\n\nReducers.userInterface = function userInterface(state, action) {\n  state = state || initialInterfaceState;\n\n  switch (action.type) {\n    case 'SELECT_CARD':\n      // we happen to be replacing all the reducers state but with merge you\n      // could just return the selectedId and it would retain selectedPlayerName\n      return merge(state, {\n        selectedId: action.cardId,\n      });\n    default:\n      return state;\n  }\n}\n\nReducers.cards = function players(state = [], action) {\n  switch (action.type) {\n    case 'CARDS_CHANGED':\n      // we don't have to merge the single doc that changes since minimongo\n      // keeps the entire cache for us. We'll just return the new minimongo state\n      // We *could* also return another fetch if sorting wasn't so easy here\n      let docs = _.clone(action.collection); // clone to prevent mutating action!!\n      return docs.sort((a,b) => b.title - a.title);\n    default:\n      return state;\n  }\n}\n"]}